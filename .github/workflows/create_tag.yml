---
###################################################################################
# GitHub workflow to automatically create a PR against 'main' branch,
# when there is a PR on 'rel-*' branch created.
#
# 1. It checks if the PR already exist and if so, does not create one.
# 2. In future we can enhance it to read the branch name from Jira label or
#    equivalent and then create PR. This way we can extend it to multiple
#    forward merges.
###################################################################################
name: Create tag on release branch
on:
  pull_request:
    types: [closed]
    branches:
      - 'rel-*'
      - 'main'

jobs:
  create-tag-on-merge:
    runs-on: ubuntu-latest
    outputs:
      tag_ref_output: ${{ steps.tag_output.outputs.tag_ref }}
    env:
       SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL  }}
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Find latest tag
        run: |
          latest_tags+=("$(git tag --contains '${{ github.event.pull_request.base.sha }}')")
          for tag in $latest_tags; do tag_arr+=($tag); done
          echo "TAGS=${tag_arr[@]}" >> $GITHUB_ENV
        id: latest_tag

      - name: Create tag and update ref
        uses: actions/github-script@v6.3.3
        id: create_tag
        with:
          github-token: ${{ secrets.CIPIPELINE_NEXUS_PASSWORD  }}
          script: |
            latest_tag = '0.0.0'
            // process multiple tags if any
            tags = "${{ env.TAGS }}".split(' ')
            if (tags.length == 1) {
              latest_tag = tags[0]
            } else {
              if ("${{ github.event.pull_request.base.ref }}" == "main") {
                for (i in tags) {
                  tag = tags[i]
                  console.log("Checking tag " + tag)
                  if (latest_tag == null) {
                    latest_tag = tag
                    continue
                  }
                  latest_parts = latest_tag.split(".")
                  tag_parts = tag.split(".")
                  for (i = 0; i < tag_parts.length; i++) {
                    if (parseInt(tag_parts[i]) < parseInt(latest_parts[i])) {
                      console.log("Skipping " + tag)
                      break
                    }
                    if (parseInt(tag_parts[i]) > parseInt(latest_parts[i])) {
                      latest_tag = tag
                      console.log("Setting " + latest_tag)
                      break
                    }
                  }
                }
              } else {
                tag_base = "${{ github.event.pull_request.base.ref }}".substring(4).split(".").slice(0,2)
                latest_tag = tag_base.join(".") + ".0"
                for (i in tags) {
                  tag = tags[i]
                  console.log("branch - Checking tag " + tag)
                  tag_parts = tag.split(".")
                  if (tag_base[0] == tag_parts[0] && tag_base[1] == tag_parts[1]) {
                    latest_parts = latest_tag.split(".")
                    if (parseInt(latest_parts[2]) < parseInt(tag_parts[2])) {
                      latest_tag = tag
                    }
                  }
                }
              }
            }
            console.log("Latest tag: " + latest_tag)

            // check if we have
            if ( latest_tag == '' || latest_tag === undefined) {
              console.log("Couldn't determine the latest tag, exiting. Retry manually..")
              process.exit(1);
            }

            // increase the minor version lineraly to get the new tag
            tag_parts = latest_tag.split('.')
            new_tag = [tag_parts[0], tag_parts[1], parseInt(tag_parts[2]) + 1].join('.')

            // head of the branch needs to be tagged
            sha_to_tag = "${{ github.event.pull_request.merge_commit_sha }}"

            console.log("Creating tag: " + new_tag + " against commit " + sha_to_tag)

            result = await github.rest.git.createTag({
                owner: "${{ github.repository_owner }}",
                repo: "${{  github.repository }}".split('/')[1],
                tag: new_tag,
                message: 'Tag created by CI pipeline',
                type: 'commit',
                object: sha_to_tag
            });

            console.log(result)

            fullTagName = "refs/tags/" + new_tag

            console.log("Updating tag with REF: " + fullTagName)

            newRef = await github.rest.git.createRef({
                owner: "${{ github.repository_owner }}",
                repo: "${{  github.repository }}".split('/')[1],
                ref: fullTagName,
                sha: sha_to_tag
            });
            console.log('Ref updated.');
            core.setOutput('tag_ref', new_tag)  

      - name: Tag Output
        id: tag_output
        run: |
          echo "tag_ref=${{steps.create_tag.outputs.tag_ref}}" >> $GITHUB_OUTPUT

      - name: Set Label
        id: set_label
        shell: bash
        run: |
          if [ -f convoy.yaml ]; then
            echo "convoy_exists=true" >> $GITHUB_OUTPUT
            if [[ "${{ github.event.pull_request.base.ref }}" == "main" ]]; then
              TOKEN=$(echo -n '${{secrets.CIPIPELINE_NEXUS_USERNAME}}:${{secrets.CIPIPELINE_NEXUS_PASSWORD}}' | base64 -w 0)
              APP_GROUP=$(yq '.appGroup // "tessell"' convoy.yaml)
              URL="http://api.convoy.tessell.cloud/devops/applications/app-groups/$APP_GROUP/latest-main-release-label"
              RESPONSE=$(curl -f --location "$URL" --header "Authorization: Basic $TOKEN")
              echo "$RESPONSE"
              LABEL=$(echo "$RESPONSE" | jq -r '.["latest-main-release-label"]')
              echo "$LABEL"
              if [[ $LABEL == rel-* ]]; then
                  echo "LABEL=$LABEL" >> $GITHUB_ENV
              else
                  echo "Response: $LABEL"
                  echo "Label does not start with 'rel'. Check response."
                  exit 1 
              fi
            else
              echo "LABEL=${{ github.event.pull_request.base.ref }}" >> $GITHUB_ENV
            fi
           else
            echo "convoy.yaml not found"
            echo "convoy_exists=false" >> $GITHUB_OUTPUT
           fi 

      - name: Validate Label
        if: ${{ steps.set_label.outputs.convoy_exists == 'true' }}
        run: |
          tag=$(echo ${{steps.create_tag.outputs.tag_ref}} | cut -d '.' -f 2)
          label=$(echo ${{env.LABEL}} | cut -d '.' -f 2)
          if [ "$tag" == "$label" ]; then
              echo "TAG and LABEL are on same release label: rel-$TAG"
          else
              echo "TAG and LABEL are on different release label. Please check git tag and API response."
              exit 1
          fi   

      - name: Slack Notification
        uses: act10ns/slack@v1.5.0
        with:
           status: ${{ job.status }}
           steps: ${{ toJson(steps) }}
           channel: ${{ secrets.SLACK_DEVOPS_CHANNEL  }}
        if: failure()

  push-commit-details-to-convoy: 
    runs-on: ubuntu-latest
    needs: create-tag-on-merge
    env:
      SLACK_WEBHOOK_URL: ${{ secrets.CONVOY_ALERTS_SLACK_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          ref: ${{github.event.pull_request.base.ref}}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v2

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pyyaml pybase64

      - name: POST API to Convoy
        env:
          API_URL: http://api.convoy.tessell.cloud/devops/git-metadata/commits
          COMMIT_HASH: "${{github.sha}}"
          REPO: "${{github.event.pull_request.base.repo.name}}"
          TAG: "${{needs.create-tag-on-merge.outputs.tag_ref_output}}"
          BASE_BRANCH: "${{github.event.pull_request.base.ref}}"
          PR_ID: "${{github.event.number}}"
          GITHUB_TOKEN: ${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}
          USER: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
        run: |
          python - <<EOF
          
          import yaml
          import requests
          import os
          import time
          import base64
          import subprocess

          def delete_keys(data, keys_to_exclude):
            for key in keys_to_exclude:
                try:
                    del data[key]
                except:
                    print(f'{key} not present in convoy.yaml')
            return data
          
          def get_artifacts(generates, version):
              artifacts=[]
              for artifact_type, artifact in generates.items():
                  for object in artifact:
                    element={}
                    element["type"] = artifact_type
                    try:
                      element["releaseManifestKey"] = object["releaseManifestKey"] 
                    except:
                        print("Artifact excluded from Release Manifest") 
                        return
                    element["name"] = object["name"]
                    element["version"] = version
                    if artifact_type == 'helmCharts':
                      chart_path = object["chartPath"]
                      with open(chart_path, 'r') as chart_yaml_content:
                        data = yaml.safe_load(chart_yaml_content)
                      element["version"] = data.get('version')
                    try:
                      element["extension"] = object["extension"]
                    except:
                      print("Extension Details not present")
                    artifacts.append(element)
              return artifacts
          
          def post_request(payload):
            API_URL = os.environ.get('API_URL')
            CONVOY_AUTH_TOKEN = os.environ.get('USER')+':'+ os.environ.get('GITHUB_TOKEN')
            CONVOY_AUTH_TOKEN = base64.b64encode(CONVOY_AUTH_TOKEN.encode('utf-8')).decode('utf-8')
            headers = {
              'Authorization': f'Bearer {CONVOY_AUTH_TOKEN}',
              'Content-Type': 'application/json'
            }
            max_retries = 3
            retry_delay = 5 

            for _ in range(max_retries):
                response = requests.post(API_URL, json=payload, headers=headers)
                if response.status_code == 200 or response.status_code == 409:
                    print(response.status_code)
                    print(response.text)
                    break
                else:
                    print(response.status_code)
                    print(response.text)
                    print(f"Retrying... ({max_retries - _} attempts left)")
                    time.sleep(retry_delay)
            else:
                print("API request failed after retries.")
                exit(1)
            print("POST request Complete")
            return
            
          REPO = os.environ.get('REPO')
          COMMIT_HASH = os.environ.get('COMMIT_HASH')
          BASE_BRANCH = os.environ.get('BASE_BRANCH')
          PR_ID = os.environ.get('PR_ID')
          TAG = os.environ.get('TAG')
          COMMIT_MESSAGE = subprocess.check_output(['git','log','--pretty=format:%s','-n','1'])
          COMMIT_MESSAGE = COMMIT_MESSAGE.decode('utf-8')

          try:
            with open('convoy.yaml', 'r') as yaml_file:
                yaml_data = yaml.safe_load(yaml_file)
          except FileNotFoundError:
              print(f"YAML file not found. Skipping this step.")
              exit(0)
          payload = { 
            "repoName": REPO,
            "commitHash": COMMIT_HASH[:7],
            "commitMessage": COMMIT_MESSAGE,
            "baseBranch": BASE_BRANCH,
            "tag": TAG,
            "pullRequestId": PR_ID,
          }
          generates = yaml_data.get('generates')
          type = yaml_data.get('artifactType') 
          if generates != None:
              version = yaml_data.get('version')
              if version == None:
                version = TAG
              payload["artifacts"] = get_artifacts(generates, version)
              if payload["artifacts"] == None:
                del payload["artifacts"]
              print(payload)
          elif type == None:
              print(payload)
          else: 
              payload["artifactMetadata"] = get_artifact_metadata(yaml_data,type)
              print(f"Payload: {payload}")
          post_request(payload)
          EOF

      - name: Slack Notification
        uses: act10ns/slack@v1.5.0
        with:
            status: ${{ job.status }}
            steps: ${{ toJson(steps) }}
            channel: ${{ secrets.CONVOY_ALERTS_SLACK_CHANNEL  }}
        if: failure()
